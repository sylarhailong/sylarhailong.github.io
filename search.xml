<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iframe和父窗口通信]]></title>
    <url>%2F2017%2F09%2F02%2Fiframe%E5%92%8C%E7%88%B6%E7%AA%97%E5%8F%A3%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[之前做过一个需求，合作方要求以iframe的形式将我们的页面嵌入到他们的页面中，就涉及到了iframe和父窗口的通信，一般需要通信的内容就是发送高度，对方接受到信息后设置iframe的高度，保证iframe正常显示，不会遮挡内容也不会出现滚动条。 实现方案 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全 语法介绍iframe内使用postMessage postMessage(message, targetOrigin, [transfer]); message 将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。 targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 transfer 可选 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 父窗口监听message123456789101112window.addEventListener(&quot;message&quot;, receiveMessage, false);function receiveMessage(event)&#123; // For Chrome, the origin property is in the event.originalEvent // object. var origin = event.origin || event.originalEvent.origin; if (origin !== &quot;http://example.org:8080&quot;) return; // ...&#125; message 的属性有: data 从其他 window 中传递过来的对象。 origin 调用 postMessage 时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “https://example.org (implying port 443)”、“http://example.net (implying port 80)”、“http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。 source 对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。 实际使用经验 post高度的时候，一般使用document.body.clientHeight获取iframe内的内容的高度 为了快速设置高度，可以在未加载完成的时候，就先post一个高度，等页面onload的时候在post一次高度 注意在页面高度变化的时候需要重新设置高度，页面高度变化一般都是由于发生点击重绘页面，因此点击的时候需要post高度，有时会异步请求一些资源，如果不能在callback中设置高度，可以通过设置定时器不断post高度来解决 postMessage不仅仅是用来设置高度，可以处理任何消息，不要思维定视 参考资料MDN web docs]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置详解]]></title>
    <url>%2F2017%2F08%2F17%2Fnginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[nginx是一个很强大的高性能Web和反向代理服务器，每次修改nginx配置都需要重新整理查找，因此总结了nginx配置信息，便于以后查阅.本文主要介绍nginx.conf的配置，与具体业务相关的配置不包含在此部分内容中。 nginx.conf的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#nginx用户组user nobody nobody; #nginx工作进程数worker_processes 8; #nginx可以使用gdb进行调试,Crash的时候产生Core文件#working_directory表示Core文件存放的目录#worker_rlimit_core表示单个worker子进程所使用的Core文件大小的最大值working_directory /test/nginx;worker_rlimit_core 2G;#错误日志error_log logs/error.log error;pid sbin/nginx.pid;#指定进程可以打开的最大描述符：数目。#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除#但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在Linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡#所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 51200;events&#123; use epoll; #使用epoll的I/O 模型，感兴趣的可以仔细了解下每个I/O模型的区别 不同操作系统下配置不同 worker_connections 51200; #每个工作进程的最大连接数量 理论上每台nginx服务器的最大连接数为：worker_processes*worker_connections&#125;http&#123; #nginx通过服务器端文件的后缀名来判断这个文件属于什么类型，再将该数据类型写入HTTP头部的Content-Type字段中，发送给客户端 include mime.types; #nginx默认返回的Content-Type字段 default_type application/octet-stream; #set_real_ip_from指令是告诉nginx，10.0.0.0是我们的反代服务器，不是真实的用户IP，可以包含多行这个配置 set_real_ip_from 10.0.0.0/8; set_real_ip_from 192.168.0.0/16; #当real_ip_recursive为off时，nginx会把real_ip_header指定的HTTP头中的最后一个IP当成真实IP #当real_ip_recursive为on时，nginx会把real_ip_header指定的HTTP头中的最后一个不是信任服务器的IP当成真实IP #当用户访问到我们的网站过程中经过多个路由转发，所以X-Forwarded-For应该是101.10.33.11, 192.168.0.10， #如果设置成off，取到的ip是192.168.0.10，如果设置成on，获得的ip为101.10.33.11，把取得的这个ip当成用户真实的ip real_ip_recursive on; #real_ip_header则是告诉nginx真正的用户IP是存在X-Forwarded-For请求头中 real_ip_header X-Forwarded-For; include xnet.conf; #日志格式 log_format main &apos;$host $remote_addr [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos; &apos;$ip2loc_code4 $cookie_SUID $request_time $cookie_SSUID &apos; &apos;$http_x_forwarded_for $request_length $cookie_YYID &apos;; log_format mini &apos;$time_local $status $body_bytes_sent $request_time $server_name $status $request_uri&apos;; #访问日志打印地址 access_log &quot;logs/$&#123;server_name&#125;_access_log&quot; main; access_log logs/status_log mini; #给站点配置多个别名的时候需要配置该选项 server_names_hash_bucket_size 128; #指定客户端请求的http头部缓冲区大小绝大多数情况下一个头部请求的大小不会大于1k不过如果有 #来自于wap客户端的较大的cookie它可能会大于1k，nginx将分配给它一个更大的缓冲区 #这个值可以在large_client_header_buffers里面设置。 #这两个配置只针对get请求，post请求的配置可自行查阅 client_header_buffer_size 32k; large_client_header_buffers 4 32k; #允许客户端请求的最大单文件字节数。如果有上传较大文件，需要设置，防止返回给用户返回413 client_max_body_size 20m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。 #对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载 sendfile on; #在Linux上使用TCP_CORK套接字选项,关于此字段和下个字段的详解看文后的链接文章 tcp_nopush on; #发送应立即发出的短消息 tcp_nodelay on; #client_header_buffer_size用于指定响应客户端的超时时间。 #这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。 send_timeout 300; #以下两个配置都是http_proxy模块的配置 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 2; #连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时) proxy_read_timeout 5; #nginx连接resin采用hmux协议 提高效率 hmux_temp_path /dev/shm/nginx/hmux_temp/; hmux_buffers 4 16k; hmux_connect_timeout 2s; hmux_read_timeout 7s; hmux_send_timeout 6s; hmux_buffer_size 16k; hmux_flush always; #定义路径下默认访问的文件名，一般跟着root放 index index.html index.htm index.shtml; #设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。 #建议设置成大于1k的字节数，小于1k可能会越压越大 gzip_min_length 1000; #gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu) gzip_comp_level 6; #匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。 gzip_types text/plain text/xml application/x-javascript text/css application/xml; #该命令的作用是显示或隐藏掉版本,出现错误的时候看不到nginx的版本信息 server_tokens off; #业务相关的配置独立出来 include vhosts/*.conf;&#125; 整理过程中参考有用的文章 nginx服务器安装及配置文件详解 TCP_NODELAY 和 TCP_NOPUSH The module implements resin’s hmux protocol in nginx Nginx配置文件（nginx.conf）配置详解]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx.conf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows环境nodejs版本管理]]></title>
    <url>%2F2017%2F08%2F12%2Fwindow%E4%B8%8Bnodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[由于业务需要使用nodejs，由于nodejs版本更新频繁，为方便使用通过安装nodejs版本管理器来解决这个问题，实验了两种方案，踩过一点小坑，记录一下 nvmw方案nvmw方案是cnode社区上给出的nodejs版本管理方案，尝试按照提示步骤进行，期间遇到了几个问题1nvmw install v6.11.2 提示“没有文件扩展”.js”的脚本引擎”这样的错误,原因是因为JS扩展名的文件被其他软件关联了，需要取消关联。采用的解决方案是：在运行中输入“regedit”进入注册表，把[HKEY_CLASSES_ROOT.js]项下的那个默认值改成”JSFile”就可以正常运行JS 文件了。解决了这个问题之后重新执行命令，又出现新的错误cscript不是内部或外部命令,未找到合适的解决方案，因此寻找新的方案。有成功的例子详见这篇文章 nvm-windows方案此方案比较简单，按照说明安装软件即可，顺利达到目的中间过程中踩了一个坑，在nvm use的命令的时候失效，原因是软件我安装在programe file下了，路径中存在空格，重新安装软件在全英文路径下，安装成功。建议安装路径不要又空格和中文。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
</search>
